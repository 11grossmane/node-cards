{"name":"node-cards","body":"# Install\r\n\r\n```bash\r\n$ npm install cards\r\n```\r\n\r\n# Usage\r\n\r\n```javascript\r\nvar cards = require('cards');\r\n\r\n// Create a new 52 card poker deck\r\nvar deck = new cards.PokerDeck();\r\n\r\n// Shuffle the deck\r\ndeck.shuffleAll();\r\n\r\n// Draw a card\r\nvar card = deck.draw();\r\nconsole.log(card);\r\n```\r\n\r\n## Creating a Deck\r\n\r\nThere are multiple built-in deck types. These include `PokerDeck`, `OldMaidDeck`, `EuchreDeck`, `PinochelDeck`, and `PiquetDeck`. The only one of these that can take any parameters is the poker deck which takes a config object, allowing the addition of jokers.\r\n\r\n```javascript\r\nvar deckWithJokers = new cards.PokerDeck({ jokers: 2 });\r\n```\r\n\r\nOptionally, you can also create an empty deck and add cards to it your self. This is done with the base `Deck` constructor.\r\n\r\n```javascript\r\nvar deck = new cards.Deck();\r\n\r\n// The new deck is completely empty\r\nconsole.log(deck.cards.length);  // 0\r\n\r\n// Add a new card to the deck\r\ndeck.add(new cards.Card('spade', 3));\r\n```\r\n\r\nYou can extend the base constructor to create your own custom deck types.\r\n\r\n```javascript\r\n// The generators object contains functions for creating new decks\r\ncards.generators.ourWeirdDeck = function(deck) {\r\n\t['club', 'diamond', 'heart', 'spade'].forEach(function(suit) {\r\n\t\t[2, 4, 6, 8, 10, 'Q'].forEach(function(value) {\r\n\t\t\tdeck.add(new cards.Card(suit, value));\r\n\t\t});\r\n\t});\r\n};\r\n\r\n// Create the new deck constructor and point it to our generator\r\ncards.Deck.createType('WeirdDeck', 'ourWeirdDeck');\r\n\r\n// Now we can create instances of our new deck type\r\nvar weirdDeck = new cards.WeirdDeck();\r\n```\r\n\r\n## Piles\r\n\r\nEach deck consists of three \"piles\" of cards. No card can appear in more than one pile at a time and every card exists in one of the three piles at all times. These piles are `\"deck\"`, `\"held\"`, and `\"discard\"`. By default, all cards in a deck are in the `deck` pile. When a card is drawn, it is moved to the `held` pile and when discarded, it is moved to the `discard` pile.\r\n\r\n```javascript\r\nvar deck = new cards.PokerDeck();\r\n\r\ndeck.deck.length === 52;\r\ndeck.held.length === 0;\r\ndeck.discard.length === 0;\r\n\r\ndeck.draw();\r\n\r\ndeck.deck.length === 51;\r\ndeck.held.length === 1;\r\ndeck.discard.length === 0;\r\n\r\n// This is a shortcut for deck.discard(deck.draw())\r\ndeck.drawToDiscard();\r\n\r\ndeck.deck.length === 50;\r\ndeck.held.length === 1;\r\ndeck.discard.length === 1;\r\n```\r\n\r\n## API\r\n\r\n### Boolean cards.useArc4 = false\r\n\r\nThe `useArc4` flag changes how cards are shuffled. By default, the randomization needed for shuffling is creating using the built-in `Math.random()` function. By setting this flag to true, all shuffle functions will instead use the better (but slower) ARC4 <abbr title=\"Psuedo-Random Number Generator\">PRNG</abbr>.\r\n\r\n### cards.Card ( String suit, String value )\r\n\r\nThe constructor for creating new playing card objects.\r\n\r\n#### String Card::suit\r\n\r\nThe suit of the card. The only suits created by the built-in types are \"spade\", \"heart\", \"club\", \"diamond\", and \"other\" (for special cards like jokers).\r\n\r\n#### String Card::value\r\n\r\nThe value of the card. This value is cast to a string, so things like `new Card(\"spade\", 3)` will work, but this property will produce the value `\"3\"` as a string.\r\n\r\n#### Deck Card::deck\r\n\r\nThe deck object that this card belongs to.\r\n\r\n### cards.Pile < Array ( void )\r\n\r\nThis constructor creates the \"deck\", \"held\", and \"discard\" piles inside of each deck. The pile constructor inherits from `Array`.\r\n\r\n#### Array Pile::empty ( void )\r\n\r\nEmpties out the pile and returns an array of the values removed.\r\n\r\n#### void Pile::copyInto ( Array arr )\r\n\r\nCopy all values onto the end of another array (or array-like object).\r\n\r\n#### void Pile::emptyInto ( Array arr )\r\n\r\nEmpty out the pile and append all of the values onto the end of another array (or array-like object).\r\n\r\n#### mixed Pile::shiftInto ( Array arr )\r\n\r\nShift one value off of the pile and push it onto another array (or array-like object).\r\n\r\n### cards.Deck ([ mixed generator ])\r\n\r\nThe base constructor for creating new decks of cards. The generator argument is either a string (the name of a function on the `cards.generators` object) or a function.\r\n\r\n#### void Deck::add ( Card card[, Object cfg { pile: \"deck\" } ])\r\n\r\nAdds a card to the deck. If the card is already in a deck, it will first be removed from that deck. The optional config object takes one property `pile` which controlls which of the three piles the card will be added to.\r\n\r\n#### void Deck::remove ( Card card )\r\n\r\nRemoves a card from the deck.\r\n\r\n#### mixed Deck::draw ([ Number count ])\r\n\r\nDraws a card(s) from the \"deck\" pile, moving them into the \"held\" pile and returns it. If there are no cards left in the deck, a `RangeError` will be thrown. If a count value is given, that many cards will be drawn and returned in an array. If there are cards in the deck, but not enough to meet the count requirement, all of the remaining cards will be returned in an array and no error will be throw. As such, you should check the length of the array you get back when doing multiple card draws.\r\n\r\n#### mixed Deck::drawToDiscard ([ Number count ])\r\n\r\nThis method works the same as `Deck::draw()` except that cards are moved to \"discard\" instead of held.\r\n\r\n#### Array Deck::find ([ mixed card ])\r\n\r\nFinds a card in the deck. If the argument given is a `Card` object, that specific card will be found and returned with some extra positional information (see below). An array argument can also be given, though, in the format `[suit, value]`. If this is the case, all matching cards will be found (there can be more than one of the same kind of card in a deck, for example, in a Pinochel deck where every card is duplicated).\r\n\r\n```javascript\r\nvar card = deck.draw();\r\n\r\nvar found = deck.find(card);\r\n\r\n// \r\n// found = [\r\n//   {\r\n//     pileName: String,  (eg. \"deck\" or \"discard\")\r\n//     pile: cards.Pile,  (the actual Pile object)\r\n//     index: Number,     (the card's index in the pile)\r\n//     card: cards.Card   (the actual Card object)\r\n//   }\r\n// ]\r\n//\r\n\r\n// You can also search for a card by description, like so:\r\ndeck.find([ \"spade\", \"A\" ]);\r\n```\r\n\r\n#### void Deck::shuffleAll ( void )\r\n\r\nMoves all cards back into the \"deck\" pile and shuffles.\r\n\r\n#### void Deck::shuffleRemaining ( void )\r\n\r\nShuffles all cards remaining in the \"deck\" pile.\r\n\r\n#### void Deck::shuffleDiscard ( void )\r\n\r\nShuffles all cards in the \"discard\" pile and then appends them to the deck.\r\n\r\n#### void Deck::discardAllHeld ( void )\r\n\r\nMoves all cards from the \"held\" pile to the \"discard\" pile.\r\n\r\n### void cards.Deck.createType ( String name[, mixed generator[, function constructor ]])\r\n\r\nCreates a new constructor at `cards[name]` that will create a new deck using the given generator. If a constructor function is given it will be called after invoking the `Deck` constructor.\r\n\r\n### cards.PokerDeck < cards.Deck ([ Object cfg { jokers: 0 } ])\r\n\r\nCreates a new Poker deck. If the config object is given, the number given in the `jokers` property will determine the number of joker cards added to the deck.\r\n\r\n### cards.OldMaidDeck < cards.Deck ( void )\r\n\r\nCreates a new Old Maid deck: a standard Poker deck with no jokers and a special card called a \"maid\" card.\r\n\r\n### cards.EuchreDeck < cards.Deck ( void )\r\n\r\nCreates a new Euchre deck.\r\n\r\n### cards.PinochelDeck < cards.Deck ( void )\r\n\r\nCreates a new Pinochel deck.\r\n\r\n### cards.PiquetDeck < cards.Deck ( void )\r\n\r\nCreates a new Piquet deck.\r\n\r\n# MIT License\r\n\r\nCopyright (c) 2012 James Brumond\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","tagline":"A Node.js playing card module with support for custom decks","google":"UA-32428216-1","note":"Don't delete this file! It's used internally to help with page regeneration."}