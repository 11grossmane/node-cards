<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: hands/evaluator.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: hands/evaluator.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
const { Hand } = require('./hand');
const { Card } = require('../card');
const { standardHandRanking } = require('./ranking');

/**
 * @typedef HandEvaluatorOptions
 * @property wilds {Card[]}
 * @property bugs {Card[]}
 * @property aces {'low'|'high'|'split'|'low-or-high'}
 * @property handRanking {Function.&lt;Hand>[]}
 */

const props = new WeakMap();

/**
 * Used to evaluate a set of cards for poker hands
 *
 * wilds - A list of all cards that should be treated as full wild cards
 * bugs - A list of all cards that should be treated as [bug cards](https://en.wikipedia.org/wiki/Bug_\(poker\))
 * aces - The rule for Ace ranking; "high", "low", "high-or-low", or "split"
 * handRanking - An array of Hand classes, in order from best to worst, to determine what the best hand is
 *
 * @class HandEvaluator
 */
exports.HandEvaluator = class HandEvaluator {
	constructor(/** @type {HandEvaluatorOptions} */ { wilds = [ ], bugs = [ ], aces = 'low-or-high', handRanking = standardHandRanking }) {
		props.set(this, {
			wilds: new Set(wilds),
			bugs: new Set(bugs),
			aces,
			handRanking
		});
	}

	evaluateHand(cards) {
		const { wilds, bugs, aces, handRanking } = props.get(this);
		const { naturalCards, wildCards, bugCards } = separateWildCards(cards, wilds, bugs);

		const { cardsByRank, cardsBySuit } = separateCardsByRankAndSuit(naturalCards);
		const { groupsBySize } = findRankGroupings(cardsByRank);

		const handDetails = new HandDetail({ cards, naturalCards, wildCards, bugCards, cardsByRank, cardsBySuit, groupsBySize, aces });

		let hand;

		handRanking.some((HandType) => {
			hand = HandType.find(handDetails);

			if (hand) {
				return true;
			}
		});

		return hand;
	}
};

/**
 * Separates out a hand of cards into 3 lists: natural cards, wild cards, and bug cards
 *
 * @param cards {Card[]}
 * @param wildCardSet {Set.&lt;Card>}
 * @param bugCardSet {Set.&lt;Card>}
 * @return {{ naturalCards: Card[], wildCards: Card[], bugCards: Card[] }}
 */
const separateWildCards = (cards, wildCardSet, bugCardSet) => {
	let wildCards = [ ];
	let bugCards = [ ];

	const naturalCards = cards.slice();

	for (let i = 0; i &lt; naturalCards.length; i++) {
		const card = naturalCards[i];

		if (wildCardSet.has(card)) {
			wildCards.push(card);
			naturalCards.splice(i--, 1);
		}

		else if (bugCardSet.has(card)) {
			bugCards.push(card);
			naturalCards.splice(i--, 1);
		}
	}

	return {
		naturalCards,
		wildCards,
		bugCards
	};
};

/**
 * Separates cards into buckets by rank
 *
 * @param cards {Card[]}
 * @return {{ cardsByRank: Map.&lt;Rank, Card[]>, cardsBySuit: Map.&lt;Rank, Card[]> }}
 */
const separateCardsByRankAndSuit = (cards) => {
	const cardsByRank = new Map();
	const cardsBySuit = new Map();

	cards.forEach((card) => {
		const { rank, suit } = card;

		if (! cardsByRank.has(rank)) {
			cardsByRank.set(rank, [ ]);
		}

		if (! cardsBySuit.has(suit)) {
			cardsBySuit.set(suit, [ ]);
		}

		cardsByRank.get(rank).push(card);
		cardsBySuit.get(suit).push(card);
	});

	return { cardsByRank, cardsBySuit };
};

/**
 * Organizes cards by the number of cards for that rank that exists (ie. it finds pairs, three of a kinds, etc)
 *
 * @param naturalCardsByRank {Map.&lt;Rank, Card[]>}
 * @return {{ groupsBySize: { [size: number]: Card[][] } }}
 */
const findRankGroupings = (naturalCardsByRank) => {
	const groupsBySize = {
		'5': [ ],
		'4': [ ],
		'3': [ ],
		'2': [ ]
	};

	naturalCardsByRank.forEach((cards/*, rank*/) => {
		if (cards.length > 1) {
			groupsBySize[cards.length].push(cards);
		}
	});

	return { groupsBySize };
};

/**
 * Contains some general metadata about a hand of cards, used for determining the value
 * of the hand.
 *
 * @class HandDetail
 */
class HandDetail {
	constructor({ cards, naturalCards, wildCards, bugCards, cardsByRank, cardsBySuit, groupsBySize, aces }) {
		this.cards = cards;
		this.naturalCards = naturalCards;
		this.wildCards = wildCards;
		this.bugCards = bugCards;
		this.cardsByRank = cardsByRank;
		this.cardsBySuit = cardsBySuit;
		this.groupsBySize = groupsBySize;
		this.aces = aces;

		Object.freeze(this);
	}
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-cards.html">cards</a></li><li><a href="module-rand.html">rand</a></li><li><a href="module-ranks.html">ranks</a></li></ul><h3>Classes</h3><ul><li><a href="Card.html">Card</a></li><li><a href="Deck.html">Deck</a></li><li><a href="HandDetail.html">HandDetail</a></li><li><a href="HandEvaluator.html">HandEvaluator</a></li><li><a href="Rank.html">Rank</a></li><li><a href="Suit.html">Suit</a></li></ul><h3>Global</h3><ul><li><a href="global.html#deuces">deuces</a></li><li><a href="global.html#findRankGroupings">findRankGroupings</a></li><li><a href="global.html#jokers">jokers</a></li><li><a href="global.html#oneEyedJacks">oneEyedJacks</a></li><li><a href="global.html#separateCardsByRankAndSuit">separateCardsByRankAndSuit</a></li><li><a href="global.html#separateWildCards">separateWildCards</a></li><li><a href="global.html#suicidalKings">suicidalKings</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Sep 17 2018 22:20:42 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
